---
description: Development workflow guidelines for kurtosis-sync-test
globs:
  - "**/*.sh"
  - "**/*.yaml"
  - ".github/**/*"
  - "ansible/**/*"
alwaysApply: false
---

# Development Workflow

## Git Workflow

### Branch Strategy
- `main`: Production-ready code
- Feature branches: `feature/description`
- Bugfix branches: `fix/description`
- No direct commits to main branch

### Commit Standards
- Use conventional commits format
- Prefix: `feat:`, `fix:`, `docs:`, `test:`, `chore:`
- Keep commits atomic and focused
- Write clear, descriptive commit messages

### Pull Request Process
1. Create feature branch from main
2. Make changes following code standards
3. Test changes locally
4. Submit PR with clear description
5. Address review feedback
6. Squash and merge when approved

## Testing Requirements

### Local Testing
Before submitting changes:
1. Run shellcheck on all modified scripts
2. Test script execution with various parameters
3. Verify YAML syntax with yamllint
4. Test with at least one client combination

### Test Scenarios
- **Smoke Test**: Single client pair, minimal wait time
- **Full Test**: All client combinations for target network
- **Edge Cases**: Network failures, timeout scenarios

### Validation Checklist
- [ ] Scripts exit cleanly on errors
- [ ] YAML configurations are valid
- [ ] Ansible playbooks run without errors
- [ ] Metrics are properly collected
- [ ] Logs are informative and clear

## Development Setup

### Prerequisites
```bash
# Install required tools
brew install kurtosis-tech/tap/kurtosis-cli
brew install yq jq shellcheck yamllint
pip install ansible ansible-lint
```

### Environment Setup
1. Clone repository
2. Copy example environment files
3. Configure metrics credentials
4. Test Kurtosis connectivity

### Development Environment
- Use consistent Docker/Kurtosis versions
- Test against latest client versions
- Maintain clean git history

## Code Review Guidelines

### Review Focus Areas
1. **Functionality**: Does the code do what it claims?
2. **Error Handling**: Are failures handled gracefully?
3. **Performance**: Are there any obvious bottlenecks?
4. **Security**: Are credentials handled safely?
5. **Documentation**: Is the code self-documenting?

### Review Checklist
- [ ] Code follows project standards
- [ ] Tests pass successfully
- [ ] Documentation is updated
- [ ] No hardcoded values
- [ ] Error messages are helpful

## CI/CD Pipeline

### Automated Checks
- Shellcheck for bash scripts
- Yamllint for YAML files
- Ansible-lint for playbooks
- Basic smoke tests

### Deployment Process
1. Merge to main triggers CI
2. Run full test suite
3. Deploy to staging environment
4. Manual approval for production

## Release Process

### Version Tagging
- Use semantic versioning: `vX.Y.Z`
- Major: Breaking changes
- Minor: New features
- Patch: Bug fixes

### Release Steps
1. Update version in relevant files
2. Update CHANGELOG
3. Create release PR
4. Tag release after merge
5. Deploy to production

## Documentation Updates

### When to Update Docs
- New features or functionality
- Changed behavior
- New configuration options
- Deprecations or removals

### Documentation Standards
- Keep README.md current
- Update inline documentation
- Document breaking changes
- Provide migration guides

## Debugging Guidelines

### Debug Mode
Enable debug output:
```bash
DEBUG=true ./synctest.sh
```

### Common Issues
1. **Kurtosis errors**: Check Docker/Kurtosis status
2. **Client sync failures**: Review Assertoor output
3. **Metrics failures**: Verify credentials and connectivity
4. **Timeout issues**: Adjust wait times for network

### Log Analysis
- Check Kurtosis logs: `kurtosis enclave logs`
- Review client logs for sync issues
- Examine Assertoor test results
- Analyze metrics for patterns

## Performance Optimization

### Script Performance
- Minimize external command calls
- Use native bash operations when possible
- Cache frequently accessed data
- Parallelize independent operations

### Resource Management
- Clean up Kurtosis enclaves after tests
- Monitor Docker resource usage
- Implement proper timeout handling
- Use efficient data structures

## Security Practices

### Credential Management
- Use environment variables
- Never commit credentials
- Rotate credentials regularly
- Use least privilege principle

### Input Validation
- Sanitize all inputs
- Validate configuration files
- Check file permissions
- Prevent command injection

## Monitoring and Alerts

### Key Metrics
- Test success/failure rates
- Sync duration trends
- Database size growth
- Resource utilization

### Alert Conditions
- Test failures
- Unusual sync times
- Resource exhaustion
- Service availability

## Contribution Guidelines

### Getting Started
1. Read project documentation
2. Set up development environment
3. Find an issue to work on
4. Discuss approach before implementing

### Code Submission
1. Fork the repository
2. Create feature branch
3. Implement changes
4. Add/update tests
5. Submit pull request

### Communication
- Use GitHub issues for bugs/features
- Discuss major changes first
- Be respectful and constructive
- Follow code of conduct